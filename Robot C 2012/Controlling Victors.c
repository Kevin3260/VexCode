#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in7,    armPot_Right,   sensorPotentiometer)
#pragma config(Sensor, in8,    armPot_Left,    sensorPotentiometer)
#pragma config(Sensor, I2C_1,  encoder_Left,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  encoder_Right,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           driveRightFront, tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1627776)
#pragma config(Motor,  port2,           driveLeftFront, tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port3,           rightArm1,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           leftArm1,      tmotorVex393, openLoop)
#pragma config(Motor,  port5,           rightArm2,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           leftArm2,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           intakeTread,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           intakeWheel,   tmotorVex393, openLoop)
#pragma config(Motor,  port9,           driveRightBack, tmotorVex393, openLoop)
#pragma config(Motor,  port10,          driveLeftBack, tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
TODO: (When complete, turn the - into a * beside the item, use a + if it is partially completed)
	+ Add autonomous selector (using LCD screen)
 	- Add yellow protection autonomouseseses
 	- Add left pickup score yellow autonomous
 	- Add left pickup yellow (from under trough) and score autonomous
 	- Comment everything and change the function names to something that makes more sense
*/

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

int getRightEncoder();
int getLeftEncoder();

// LCD Display Variables
const short leftButton = 1,
						centerButton = 2,
						rightButton = 4;

// Teleop variables and function declerations
int threshold = 10;      // Threshold for driving deadzone
int driveSlow = 1;       // Starting at 1, the greater the number, the slower it goes, formula:(value/driveSlow = speed)

void driveWithJoysticks();
void driveAtSpeed(int speed);
void stopDrive();
void intakeControl();
void stopIntake();
void positionArm(int position);
void stopArm();
int getArmPotentiometer();
void lowerArm();
void raiseArm();
void clearLCD();
void clearEncoders();
void driveForTicks(int leftTicks, int rightTicks, int speed, bool scaleSpeed);
int getArmSeperation();

/*
 * Arm Height Variables
 */
 const int Arm_MinHeight = 750,
		   		 Arm_SlowedHeight = 885,
		   		 Arm_ScoreHeight = 1800,
		   		 Arm_MaxHeight = 2200;

/*
 * Arm Speed variables
 */
const int Arm_NormalSpeed =	120,
		  		Arm_DownSpeed = 105,
		  		Arm_SlowedSpeed = 30;

/*
 * Autonomous Selection Variables
 */
const int Autonomous_None = 0,
					Autonomous_LeftScoreMatchLoads = 1,
					Autonomous_RightPickupScoreYellow = 2,
					Autonomous_ProgrammingSkills = 3;

const int Encoder_Left = 0,
					Encoder_Right = 1,
					Encoder_Both = 2;

int selectedAuton = Autonomous_LeftScoreMatchLoads;

int totalAutons = 3;

string autonNames[] = {"None", "L-Score Loads", "R-Score Yellow", "Skills"};

/*
 * Intake Speed Selection Variables
 */
enum
{
	IntakeSlow = 60,
	IntakeFast = 127,
};

int currentIntakeSpeed = IntakeFast;
int currentIntakeSpeedStep = 2;

bool btn7DPressed = 0;
bool btn7UPressed = 0;

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...

	clearLCD();

	displayLCDCenteredString(0, autonNames[selectedAuton]);
	displayLCDCenteredString(1, "<  Enter   >");

	while(nLCDButtons != centerButton) // Center LCD button is not pressed
	{
		if(nLCDButtons == 0) // There are currently no buttons pressed
		{
			wait1Msec(10); // No need to waste processor cycles
		}
		else
		{
			if(nLCDButtons == leftButton && (selectedAuton - 1) >= 0) // The left button is pressed and a subtraction of 1 won't lead to a non-choice
			{
				selectedAuton--; // Decrease our current autonomous selection index by 1
			}

			if(nLCDButtons == rightButton && (selectedAuton + 1) <= totalAutons)// The right button is pressed and an addition of 1 won't lead to a non-choice
			{
				selectedAuton++; // Increase our current autonomous selection index by 1
			}

			while(nLCDButtons != 0) // Make sure we release the button to prevent it being impossible to use 1 step
			{
				wait1Msec(10); // No need to waste processor cycles
			}
		}

		// Add our selections to the display
		clearLCDLine(0);
		displayLCDCenteredString(0, autonNames[selectedAuton]);
	}

	clearLCD();

	displayLCDCenteredString(0, autonNames[selectedAuton]);
	displayLCDCenteredString(1, "Locked In");
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	switch(selectedAuton)
	{
		case Autonomous_LeftScoreMatchLoads:
			{
				clearEncoders();

				motor[intakeTread]  = -127;
				motor[intakeWheel] = -127;

				wait1Msec(700);

				stopIntake();

				positionArm(Arm_ScoreHeight);

				stopArm();

				wait1Msec(1000);

				int leftDest = SensorValue[encoder_Left] + 2200;

				while(SensorValue[encoder_Left] < leftDest)
				{
					driveAtSpeed(60);
				}

				stopDrive();

				motor[intakeTread]  = 127;
				motor[intakeWheel] = 127;

				wait10Msec(200);
			}
			break;

		case Autonomous_RightPickupScoreYellow:
			{
				clearEncoders();

				int leftDest = SensorValue[encoder_Left] + 1850;

				while(SensorValue[encoder_Left] < leftDest)
				{
					driveAtSpeed(50);
				}

				stopDrive();

				motor[intakeTread]  = -127;
				motor[intakeWheel] = -127;

				wait1Msec(1000);

				stopIntake();

				positionArm(Arm_ScoreHeight);

				int rightDest = SensorValue[encoder_Right] - 730;

				while(SensorValue[encoder_Right] > rightDest)
				{
					motor[driveLeftBack] = 38;
					motor[driveRightBack] = 0;
					motor[driveLeftFront] = 38;
					motor[driveRightFront] = 0;
				}

				leftDest = SensorValue[encoder_Left] + 650;

				while(SensorValue[encoder_Left] < leftDest)
				{
					motor[driveLeftBack] = 38;
					motor[driveRightBack] = 40;
					motor[driveLeftFront] = 38;
					motor[driveRightFront] = 40;
				}

				stopDrive();

				motor[intakeTread]  = 127;
				motor[intakeWheel] = 127;

				wait1Msec(1500);

				stopIntake();
			}
			break;

			case Autonomous_ProgrammingSkills:
				{
					clearEncoders();

					int leftDest = SensorValue[encoder_Left] + 1850;

					while(SensorValue[encoder_Left] < leftDest)
					{
						driveAtSpeed(50);
					}

					stopDrive();

					motor[intakeTread]  = -127;
					motor[intakeWheel] = -127;

					wait1Msec(1000);

					stopIntake();

					positionArm(Arm_ScoreHeight);

					int rightDest = SensorValue[encoder_Right] - 730;

					while(SensorValue[encoder_Right] > rightDest)
					{
						motor[driveLeftBack] = 38;
						motor[driveRightBack] = 0;
						motor[driveLeftFront] = 38;
						motor[driveRightFront] = 0;
					}

					leftDest = SensorValue[encoder_Left] + 650;

					while(SensorValue[encoder_Left] < leftDest)
					{
						driveAtSpeed(40);
					}

					stopDrive();

					motor[intakeTread] = 127;
					motor[intakeWheel] = 127;

					wait1Msec(500);

					stopIntake();

					leftDest = SensorValue[encoder_Left] - 390;

					while(SensorValue[encoder_Left] > leftDest)
					{
						driveAtSpeed(-30);
					}

					stopDrive();

					positionArm(990);

					stopArm();

					rightDest = SensorValue[encoder_Right] + 660;

					while(SensorValue[encoder_Right] < rightDest)
					{
						motor[driveLeftBack] = -30;
						motor[driveLeftFront] = -30;
					}

					stopDrive();

					leftDest = SensorValue[encoder_Left] - 2050;

					while(SensorValue[encoder_Left] > leftDest)
					{
						driveAtSpeed(-50);
					}

					stopDrive();
				}
				break;

			case Autonomous_None:
			default:
				{
				}
				break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	while(true)
	{
		driveWithJoysticks();
		intakeControl();

		if(vexRT[Btn6U]== 1 && vexRT[Btn6D] == 0 && vexRT[Btn8U]== 0 && vexRT[Btn8D]== 0)
		{
			raiseArm();
		}
		else if(vexRT[Btn6U] == 0 && vexRT[Btn6D] == 1 && vexRT[Btn8U] == 0 && vexRT[Btn8D] == 0 && vexRT[Btn8R] == 0)
		{
			lowerArm();
		}
		else if(vexRT[Btn6U] == 0 && vexRT[Btn6D] == 0 && vexRT[Btn8U] == 1 && vexRT[Btn8D] == 0 && vexRT[Btn8R] == 0)
		{
			positionArm(Arm_ScoreHeight);
		}
		else if(vexRT[Btn6U] == 0 && vexRT[Btn6D] == 0 && vexRT[Btn8U] == 0 && vexRT[Btn8D] == 1 && vexRT[Btn8R] == 0)
		{
			positionArm(Arm_MinHeight);
		}
		else
		{
			stopArm();
		}

		if(vexRT[Btn7U] == 1)
		{
			if(btn7UPressed != 1)
			{
				currentIntakeSpeedStep++;

				if(currentIntakeSpeedStep > 2)
				{
					currentIntakeSpeedStep = 2;
				}

				btn7DPressed = true;
			}
		}
		else
		{
			btn7UPressed = false;
		}

		if(vexRT[Btn7D] == 1)
		{
			if(btn7DPressed != 1)
			{
				currentIntakeSpeedStep--;

				if(currentIntakeSpeedStep < 1)
				{
					currentIntakeSpeedStep = 1;
				}

				btn7DPressed = true;
			}
		}
		else
		{
			btn7DPressed = false;
		}

		switch(currentIntakeSpeedStep)
		{
		case 1:
			currentIntakeSpeed = IntakeSlow;
			break;

		case 2:
			currentIntakeSpeed = IntakeFast;
			break;

		default:
			currentIntakeSpeed = IntakeFast;
			break;
		}
	}

	while ((vexRT[Btn7D] == 1) || (vexRT[Btn7U] == 1)	|| (vexRT[Btn7R] == 1)	|| (vexRT[Btn7L] == 1))
	{
		// Wait until button is released to go back to single joystick control.
		driveWithJoysticks();
	}
}

int getRightEncoder()
{
	return abs(SensorValue(nMotorEncoder[driveRightFront]));
}

int getLeftEncoder()
{
	return abs(SensorValue(nMotorEncoder[driveLeftFront]));
}

void lowerArm()
{
	// Arm lowers
	// Speed decreases as we near the bottom.
	if(getArmPotentiometer() > Arm_SlowedHeight)
	{
		motor[rightArm1] = -Arm_DownSpeed;
		motor[rightArm2] = -Arm_DownSpeed;
		motor[leftArm1]  = -Arm_DownSpeed;
		motor[leftArm2]  = -Arm_DownSpeed;
	}
	else if(getArmPotentiometer() > Arm_MinHeight)
	{
		motor[rightArm1] = -Arm_SlowedSpeed;
		motor[rightArm2] = -Arm_SlowedSpeed;
		motor[leftArm1]  = -Arm_SlowedSpeed;
		motor[leftArm2]  = -Arm_SlowedSpeed;
	}
	else
	{
		stopArm();
	}
}

void driveWithJoysticks()
{
	if(abs(vexRT[Ch3]) > threshold)
	{
		// Tank drive left side with deadzones.
		motor[driveLeftBack]  = ((vexRT[Ch3])/driveSlow);
		motor[driveLeftFront] = ((vexRT[Ch3])/driveSlow);
	}
	else
	{
		// Stop left side movement.
		motor[driveLeftBack]  = 0;
		motor[driveLeftFront] = 0;
	}

	if(abs(vexRT[Ch2]) > threshold)
	{
		// Tank drive right side with deadzones.
		motor[driveRightBack] = ((vexRT[Ch2]) / driveSlow);
		motor[driveRightFront]  = ((vexRT[Ch2]) / driveSlow);
	}
	else
	{
		// Stop right side movement.
		motor[driveRightBack] = 0;
		motor[driveRightFront]  = 0;
	}
}

void driveAtSpeed(int speed)
{
	if(!(abs(speed) > 127))
	{
		motor[driveLeftBack] = speed;
		motor[driveLeftFront] = speed;
		motor[driveRightBack] = speed;
		motor[driveRightFront] = speed;
	}
}

void intakeControl()
{
	// Intake for 1 controller.
	if(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 0)
	{
		// Intake roller inward.
		motor[intakeTread] = currentIntakeSpeed;
		motor[intakeWheel] = currentIntakeSpeed;
	}
	else if(vexRT[Btn5D] == 0 && vexRT[Btn5U] == 1)
	{
		// Intake roller outward.
		motor[intakeTread] = -currentIntakeSpeed;
		motor[intakeWheel] = -currentIntakeSpeed;
	}
	else
	{
		// Stop intake roller movement.
		stopIntake();
	}
}

void raiseArm()
{
	int error = getArmSeperation();

	if(getArmPotentiometer() < Arm_MaxHeight)
	{
		if(abs(error) > 0)
		{
			if(error > 0) // Left arm is higher than the right arm
			{
				motor[rightArm1] = Arm_NormalSpeed;
				motor[rightArm2] = Arm_NormalSpeed;
				motor[leftArm1]  = Arm_NormalSpeed - 20;
				motor[leftArm2]  = Arm_NormalSpeed - 20;
			}
			else if(error < 0) // Right arm is higher than the left arm
			{
				motor[rightArm1] = Arm_NormalSpeed - 20;
				motor[rightArm2] = Arm_NormalSpeed - 20;
				motor[leftArm1]  = Arm_NormalSpeed;
				motor[leftArm2]  = Arm_NormalSpeed;
			}
		}
		else // The difference between arm heights is negligible
		{
			motor[rightArm1] = Arm_NormalSpeed;
			motor[rightArm2] = Arm_NormalSpeed;
			motor[leftArm1]  = Arm_NormalSpeed;
			motor[leftArm2]  = Arm_NormalSpeed;
		}
	}
	else
	{
		stopArm();
	}
}

void stopArm()
{
	motor[rightArm1] = 0;
	motor[rightArm2] = 0;
	motor[leftArm1]  = 0;
	motor[leftArm2]  = 0;
}

void stopDrive()
{
	motor[driveLeftBack] = 0;
	motor[driveLeftFront] = 0;
	motor[driveRightBack] = 0;
	motor[driveRightFront] = 0;
}

void stopIntake()
{
	motor[intakeTread] = 0;
	motor[intakeWheel] = 0;
}

void positionArm(int position)
{// Positions arm to a specified place
	if (getArmPotentiometer() < position )
	{
		while(getArmPotentiometer() < position && vexRT[Btn8R] == 0)
		{
			raiseArm();
			driveWithJoysticks();
			intakeControl();
		}

		stopArm();
	}
	else if (getArmPotentiometer() > position)
	{
		while (getArmPotentiometer() > position && vexRT[Btn8R] == 0)
		{
			lowerArm();
			driveWithJoysticks();
			intakeControl();
		}

		stopArm();
	}
}

int getArmPotentiometer()
{
	return (SensorValue[armPot_Left]);
}

void clearEncoders()
{
	nMotorEncoder[driveLeftFront] = 0;
	nMotorEncoder[driveRightFront] = 0;

	SensorValue[encoder_Left] = 0;
	SensorValue[encoder_Right] = 0;
}

void clearLCD()
{
	clearLCDLine(0);
	clearLCDLine(1);
}

void driveForTicks(int encoderSide, int encoderTicks, int speed)
{
	switch(encoderSide)
	{
		case Encoder_Left:
		default:
			{
				int leftDest = SensorValue[encoder_Left] + encoderTicks;

				if(leftDest < SensorValue[encoder_Left])
				{
					while(SensorValue[encoder_Left] < leftDest)
					{
						motor[driveLeftBack] = speed;
						motor[driveRightBack] = speed;
						motor[driveLeftFront] = speed;
						motor[driveRightFront] = speed;
					}
				}
				else
				{
					while(SensorValue[encoder_Left] > leftDest)
					{
						motor[driveLeftBack] = -speed;
						motor[driveRightBack] = -speed;
						motor[driveLeftFront] = -speed;
						motor[driveRightFront] = -speed;
					}
				}
			}
			break;

		case Encoder_Right:
			{
				int rightDest = SensorValue[encoder_Right] + encoderTicks;

				if(rightDest < SensorValue[encoder_Right])
				{
					while(SensorValue[encoder_Right] < rightDest)
					{
						motor[driveLeftBack] = speed;
						motor[driveRightBack] = speed;
						motor[driveLeftFront] = speed;
						motor[driveRightFront] = speed;
					}
				}
				else
				{
				}
			}
			break;

		case Encoder_Both:
			{
				int leftDest = SensorValue[encoder_Left] + encoderTicks;
				int rightDest = SensorValue[encoder_Right] + encoderTicks;

				while((SensorValue[encoder_Left] != leftDest) || (SensorValue[encoder_Right] != rightDest))
				{
					if(SensorValue[encoder_Left] < leftDest)
					{
						motor[driveLeftBack] = speed;
						motor[driveLeftFront] = speed;
					}
					else if(SensorValue[encoder_Left] > leftDest)
					{
						motor[driveLeftBack] = -speed;
						motor[driveLeftFront] = -speed;
					}
					else
					{
						motor[driveLeftBack] = 0;
						motor[driveLeftFront] = 0;
					}

					if(SensorValue[encoder_Right] < rightDest)
					{
						motor[driveRightBack] = speed;
						motor[driveRightFront] = speed;
					}
					else if(SensorValue[encoder_Right] > rightDest)
					{
						motor[driveRightBack] = -speed;
						motor[driveRightFront] = -speed;
					}
					else
					{
						motor[driveRightBack] = 0;
						motor[driveRightFront] = 0;
					}
				}
			}
			break;
	}

	stopDrive();
}

void driveForTicks(int leftTicks, int rightTicks, int speed, bool scaleSpeed)
{
	int leftDest = SensorValue[encoder_Left] + leftTicks;
	int rightDest = SensorValue[encoder_Right] + rightTicks;

	while((abs(SensorValue[encoder_Left] - leftDest) > 100) || (abs(SensorValue[encoder_Right] - rightDest) > 100))
	{
		if(SensorValue[encoder_Left] < leftDest)
		{
			if(abs(SensorValue[encoder_Left]) - leftDest < 200)
			{
				motor[driveLeftBack] = speed / 2;
				motor[driveLeftFront] = speed / 2;
			}
			else
			{
				motor[driveLeftBack] = speed;
				motor[driveLeftFront] = speed;
			}
		}
		else if(SensorValue[encoder_Left] > leftDest)
		{
			if(abs(SensorValue[encoder_Left]) - leftDest < 200)
			{
				motor[driveLeftBack] = -speed / 2;
				motor[driveLeftFront] = -speed / 2;
			}
			else
			{
				motor[driveLeftBack] = -speed;
				motor[driveLeftFront] = -speed;
			}
		}
		else
		{
			motor[driveLeftBack] = 0;
			motor[driveLeftFront] = 0;
		}

		if(SensorValue[encoder_Right] < rightDest)
		{
			if(abs(SensorValue[encoder_Right]) - rightDest < 200)
			{
				motor[driveRightBack] = speed / 2;
				motor[driveRightFront] = speed / 2;
			}
			else
			{
				motor[driveRightBack] = speed;
				motor[driveRightFront] = speed;
			}
		}
		else if(SensorValue[encoder_Right] > rightDest)
		{
			if(abs(SensorValue[encoder_Right]) - rightDest < 200)
			{
				motor[driveRightBack] = -speed / 2;
				motor[driveRightFront] = -speed / 2;
			}
			else
			{
				motor[driveRightBack] = -speed;
				motor[driveRightFront] = -speed;
			}
		}
		else
		{
			motor[driveRightBack] = 0;
			motor[driveRightFront] = 0;
		}
	}

	stopDrive();
}

int getArmSeperation()
{
	int leftPot = SensorValue[armPot_Left];
	int rightPot = SensorValue[armPot_Right];

	if(abs(leftPot - rightPot) > 25)
	{
		return leftPot - rightPot;
	}
	else
	{
		return 0;
	}
}
