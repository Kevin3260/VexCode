#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in7,    autonomousSelect, sensorPotentiometer)
#pragma config(Sensor, I2C_1,  left,           sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  right,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           driveRightFront, tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1627776)
#pragma config(Motor,  port2,           driveLeftFront, tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port9,           driveRightBack, tmotorVex393, openLoop)
#pragma config(Motor,  port10,          driveLeftBack, tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


// Function Declerations
int rightEncoder();
int leftEncoder();
void driveForwardInches(float inches, int speed);
void driveBackwardInches(float inches, int speed);
void pivotTurnRight(int speed);
void pivotTurnLeft(int speed);
void zeroEncoders();

// Global Variables and Constants
int rightEncoderValue;
int leftEncoderValue;
const float inchesFor90Turn = 28.27;      // Number was created by taking (distanceBetweenWheels * pi * 2)/4 = [(18 * pi * 2)/ 4] = 28.27
const float inchesPer1Revolution = 12.57; // Number was created by (diamiterOfWheel * pi) = (4 * pi) = 12.57
const float ticksPerRevolution = 627.2;   // Ticks per revolution for high torque
const int ticksPerInch = 50;              // ticksPerRevolution/inchesPer1Revolution = (627.2 / 12.57) = 49.9

task main()
{
	motor[intakeLeft]  = -127;
	motor[intakeRight] = -127;
	zeroEncoders();
	while(rightEncoder() + leftEncoder() < (1500)*2)
	{
		motor[driveLeftBack]   = 100;
		motor[driveLeftFront]  = 100;
		motor[driveRightBack]  = 100;
		motor[driveRightFront] = 100;
	}
	motor[driveLeftBack]   = 0; // Stop
	motor[driveLeftFront]  = 0;
	motor[driveRightBack]  = 0;
	motor[driveRightFront] = 0;
	motor[intakeLeft]  = 0; // Stop Arm
	motor[intakeRight] = 0;
	//zeroEncoders();
	//driveForwardInches(1,100);
	////wait10Msec(10);
	//pivotTurnLeft(100);
	////wait10Msec(10);
	//pivotTurnRight(100);
	////wait10Msec(10);
	//driveBackwardInches(12,100);
}

void pivotTurnRight(int speed)
{
	zeroEncoders();
	while(leftEncoder() - rightEncoder() < (inchesFor90Turn * ticksPerInch))
	{ // Turn right while encoders are less than target value
		motor[driveLeftBack]   = speed;
		motor[driveLeftFront]  = speed;
		motor[driveRightBack]  = -speed;
		motor[driveRightFront] = -speed;
	}
	motor[driveLeftBack]   = 0; // Stop
	motor[driveLeftFront]  = 0;
	motor[driveRightBack]  = 0;
	motor[driveRightFront] = 0;
}

void pivotTurnLeft(int speed)
{
	zeroEncoders();
	while(rightEncoder() - leftEncoder() < (inchesFor90Turn * ticksPerInch))
	{ // Turn left while encoders are less than target value
		motor[driveLeftBack]   = -speed;
		motor[driveLeftFront]  = -speed;
		motor[driveRightBack]  = speed;
		motor[driveRightFront] = speed;
	}
	motor[driveLeftBack]   = 0; // Stop
	motor[driveLeftFront]  = 0;
	motor[driveRightBack]  = 0;
	motor[driveRightFront] = 0;
}

void driveForwardInches(float inches, int speed)
{
	zeroEncoders();
	while(rightEncoder() + leftEncoder() < (inches * ticksPerInch * 2))
	{
		motor[driveLeftBack]   = speed;
		motor[driveLeftFront]  = speed;
		motor[driveRightBack]  = speed;
		motor[driveRightFront] = speed;
	}
	motor[driveLeftBack]   = 0; // Stop
	motor[driveLeftFront]  = 0;
	motor[driveRightBack]  = 0;
	motor[driveRightFront] = 0;
}

void driveBackwardInches(float inches, int speed)
{
	zeroEncoders();
	while(rightEncoder() + leftEncoder() > (-inches * ticksPerInch * 2))
	{
		motor[driveLeftBack]   = -speed;
		motor[driveLeftFront]  = -speed;
		motor[driveRightBack]  = -speed;
		motor[driveRightFront] = -speed;
	}
	motor[driveLeftBack]   = 0; // Stop
	motor[driveLeftFront]  = 0;
	motor[driveRightBack]  = 0;
	motor[driveRightFront] = 0;
}

int rightEncoder()
{ // Returns the negative value of the right encoder because of its position
	return -(SensorValue(nMotorEncoder[driveRightFront]));
}

int leftEncoder()
{ // Returns the value of the left encoder
	return SensorValue(nMotorEncoder[driveLeftFront]);
}

void zeroEncoders()
{
	SensorValue[left]  = 0;
	SensorValue[right] = 0;
}
